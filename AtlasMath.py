# Copyright [2015] [Kitware inc.]

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#  http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import numpy as np
import scipy.misc as misc
import itertools

################################


class Weighting:

    @staticmethod
    def GenerateWeights(data, stdev, center):
        weights = []
        running_sum = 0.
        for value in data:
            w = np.exp(-((value - center)**2.)/(2.*(stdev**2.)))
            weights.extend([w])
            running_sum += w
        return [i/running_sum for i in weights]


################################
class BandDepth:

    @staticmethod
    # Right now the functionsets are Dictionaries
    def IndicatorBandDepth(function, functionset, j=2): # the function set is not in the same order as the indicies think it should be
        bandDepth = 0.0
        normalizingValue = 1.0/misc.comb(len(functionset), j)
        for testBandSet in itertools.combinations(functionset, j):
            bandDepth = bandDepth + BandDepth.Indicator(function, testBandSet)
        return bandDepth*normalizingValue

    @staticmethod
    def ProportionalBandDepth(function, functionset, j=2):
        bandDepth = 0.0
        normalizingValue = 1.0/misc.comb(len(functionset), j)
        for testBandSet in itertools.combinations(functionset, j):
            bandDepth = bandDepth + BandDepth.Proportion(function, testBandSet)
        return bandDepth*normalizingValue

    @staticmethod
    def WeightedIndicatorBandDepth(key, functiondict, weightdict, j=2):
        function = functiondict[key]
        numerator = 0.0
        denominator = 0.0
        for keys in itertools.combinations(functiondict.keys(), j):
            weightSubset = BandDepth.__ExtractSubset(weightdict, keys)
            testBandSet = BandDepth.__ExtractSubset(functiondict, keys)
            product = BandDepth.__ProductOfList(weightSubset)
            denominator += product
            numerator += product*BandDepth.Indicator(function, testBandSet)
        return numerator/denominator

    @staticmethod
    def WeightedProportionalBandDepth(key, functiondict, weightdict, j=2):
        function = functiondict[key]
        numerator = 0.0
        denominator = 0.0
        for keys in itertools.combinations(functiondict.keys(), j):
            weightSubset = BandDepth.__ExtractSubset(weightdict, keys)
            testBandSet = BandDepth.__ExtractSubset(functiondict, keys)
            product = BandDepth.__ProductOfList(weightSubset)
            denominator += product
            numerator += product*BandDepth.Proportion(function, testBandSet)
        return numerator/denominator

    @staticmethod
    def Indicator(function, bandset):
        '''
        returns 1 if the function is within the band 
        generated by the bandset for all x. 0 otherwise
        '''
        for x in range(len(function)):
            bandRange = BandDepth.__BandBounds(bandset, x)
            if function[x] < bandRange[0] or function[x] > bandRange[1]:
                return 0.0
        return 1.0

    @staticmethod
    def Proportion(function, bandset):
        '''
        return the proportion of the domain where 
        function is betwen the band values
        '''
        proportion = 0.0
        for x in range(len(function)):
            bandRange = BandDepth.__BandBounds(bandset, x)
            if (bandRange[0] > function[x]) or (bandRange[1] < function[x]):
                continue
            proportion += 1.
        return proportion/len(function)

    @staticmethod
    def GenerateFences(minimum, maximum, median):
        upperfence = median + (maximum - median)*1.5
        lowerfence = median - (median - minimum)*1.5
        return [upperfence, lowerfence]

    @staticmethod
    def __BandBounds(bandset, x):
        minVal = float("inf")
        maxVal = float("-inf")

        for function in bandset:
            if function[x] < minVal:
                minVal = function[x]
            if function[x] > maxVal:
                maxVal = function[x]

        return [minVal, maxVal]

    @staticmethod
    def __ExtractSubset(objectdict, keytuple):
        output = []
        for key in keytuple:
            output.append(objectdict[key])
        return output

    @staticmethod
    def __ProductOfList(numericallist):
        r = 1.
        for i in numericallist:
            r *= i
        return r
